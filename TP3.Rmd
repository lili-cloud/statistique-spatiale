---
title: "TP3"
output: html_document
date: "2024-02-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


les packages utilisés

```{r}
# Chargement des packages
library(dplyr)
library(sf) 
library(mapsf) 
library(classInt) 
library(leaflet)
library(openxlsx)
```
## Exercice 1

Le but de cet exercice est de discrétiser une variable continue et d’en observer les diﬀérents résultats selon la méthode choisie


### Question1

 Commencez par vous créer votre jeu de données (jointure et création de variable). Attention avant de joindre vos données, il vous faudra d’abord homogénéiser la commune de Paris. Dans un ﬁchier (fond communal), Paris est renseigné sous son code communal (75056). Dans l’autre, Paris est renseigné par arrondissement (75101 à 75120). Vous devrez donc regrouper les arrondissements pour avoir une seule ligne pour Paris. Cette ligne sera renseignée avec le CODGEO 75056

```{r}
# Import des donnees 
# Fond communes France metropolitaine
communes_fm<- st_read("Fonds_carte/France_metro/commune_francemetro_2021.shp", options = "ENCODING=WINDOWS-1252") %>% 
  select(code,libelle,surf)

# Import des population légales des communes en 2019
pop_com_2019<-openxlsx::read.xlsx("Fonds_carte/Donnees/Pop_legales_2019.xlsx")

# Correction pour la ville de Paris
pop_com_2019<-pop_com_2019 %>% 
  mutate(COM=if_else(substr(COM,1,3)=="751","75056",COM)) %>% 
  group_by(code=COM) %>% 
  summarise(pop=sum(PMUN19))

# Jointure
communes_fm<-communes_fm %>% 
  left_join(pop_com_2019,
            by="code") %>% 
  mutate(densite=pop/surf)
```

### Question 2:

Regarder rapidement la distribution de la variable de densite

```{r}
summary(communes_fm$densite)
hist(communes_fm$densite, main = "Distribution de la densité", xlab = "Densité")
```
```{r}
library(ggplot2)

# Créer un histogramme avec ggplot
ggplot(communes_fm, aes(x = densite)) +
  geom_histogram(binwidth = 20, fill = "skyblue", color = "black") +
  labs(title = "Distribution de la densité",
       x = "Densité",
       y = "Fréquence")

```
### Question 3:

On souhaite représenter la variable de densite sous forme d’une carte choroplèthe. Faire cela en utilisant la fonction plot(). La variable de densité sera selectionnée par les crochets sur le modèle suivant : ma_table["ma_variable_continue"]. Ajouter également l’argument border=FALSE pour supprimer les bordures des polygônes.

```{r}
# Sélectionner la variable de densité
densite <- communes_fm["densite"]

# Tracer la carte choroplèthe
plot(densite, border = FALSE)

```
### Question 4:

On se rend compte que la carte est peu informative et qu’il vaut mieux discrétiser notre variable.
Représenter le résultat de la discrétisation de la densité de population selon les méthodes des quantiles, jenks et des écarts-types, ainsi que la méthode pretty. Vous utiliserez la fonction plot en ajoutant l’argument breaks= + le nom de la méthode. Vous analyserez les diﬀérences entre les diﬀérentes cartes.
Laquelle retiendriez-vous? Pourquoi?

```{r}
# Discrétisation de la variable de densité selon les différentes méthodes
plot(densite, breaks="quantile", main="quantile", border = FALSE)
plot(densite, breaks="sd", main="sd", border = FALSE)
plot(densite, breaks="jenks", main="jenks", border = FALSE)
plot(densite, breaks="pretty", main="pretty", border = FALSE)
```
Les cartes sont différentes suivant la méthode utilisée. En utilisant la méthode des quantiles(dans chaque classe il met le même nombre de communes, il y'a un étalement , elle n'est pas trop bonne) , sd(-pour des distributions qui ressemblent à celle normale, construit des classes autour de la moyenne; sd ne marche pas ici car notre distribution n'est pas normale); jenks(comme kmeans, construit des classe qui sont les plus différentes entre elles et plus homogènes dans chaque classe , on aura donc les plus grosses valeurs entre elles)....pretty(essaie de faire des classes jolies)
ici on laisse faire les breaks automatiquement


### Question 5:

Pour obtenir une classiﬁcation satisfaisante, il faut pouvoir comparer la distribution de la variable continue avec celle de la variable discrétisée. Le package classInt est très utile pour construire et analyser les classes.

a. Discrétiser la variable de densité avec la fonction classInt::classIntervals avec la méthode des quantiles (argument style) et 5 classes (argument n). Vous pourrez vous appuyer sur le modèle suivant :

l'objet obtenu contient deux informations: brks (les bornes des intervalles) et var (les valeurs). Plus précisément: 

```{r}
denspop_quant <- classIntervals(
  communes_fm$densite,
  style = "quantile", 
  n = 5
)
str(denspop_quant)
head(denspop_quant$var)
denspop_quant$brks 
```


b. Construire une palette de couleurs avec le code suivant:

```{r}
pal1 <- RColorBrewer::brewer.pal(n = 5, name = "YlOrRd")
```

Représenter ensuite l’objet précédent (découpage quantile) avec la fonction plot etcette palette de couleur (argument pal=). Vous ajouterez l’argument main à votre fonction plot pour préciser un titre. Analyser le graphique.

```{r}
plot(
  denspop_quant,
  pal = pal1,
  main = "quantile"
)
```
on a la fonction de répartition de notre var de départ, les communes sont assez pétites,  la derniere classe est très étendue, ce qui est un peu genant.

c. Relancer l’analyse pour les méthodes sd, jenks et pretty. 

```{r}
analyser_discret <- function(method, nb_classes){
  denspop_c <- classIntervals(
    communes_fm$densite,
    style = method, 
    n = nb_classes
  )
  print(denspop_c$brks)
  plot(
    denspop_c,
    pal = pal1,
    main = method
  )
  return(denspop_c)
}
# Avec cinq classes:
all_discret <- sapply(c("quantile", "sd","pretty","jenks"), analyser_discret, nb_classes = 5)
```


```{r}
# A partir des informations obtenues, on peut définir nos propres intervalles. 
quantile(communes_fm$densite, probs = seq(0,1,0.1))
summary(communes_fm$densite)
#40 = médiane
#162 = moyenne
#on reprend certaines bornes de Jenks - en fusionnant les derniers intervalles
# Un exemple de découpage manuel avec 7 classes
denspop_man_brks7 <- c(0,40,162,500,1000,4000,8000,27200)
# Un exemple de découpage manuel avec 5 classes
denspop_man_brks5 <- c(0,40,162,1000,8000,27200)
```
d. Finalement, on décide de discrétiser notre variable avec les bornes suivantes : [0;40[,[40;162[,[162;1000[,[1000;8000[ et [8000;27200[. Ajouter la variable discrétisée dans le fond communal. Vous utiliserez la fonction `cut`. Vous ferez attention à l'inclusion des bornes inférieures et à l'exclusion des bornes supérieures.

```{r}
popcomfm_sf <- communes_fm %>%
  mutate(
    densite_c = cut(
      densite,
      breaks = denspop_man_brks5,
      include.lowest = TRUE,
      right = FALSE,
      ordered_result = TRUE
    )
  )
```

e. Analyser la distribution de cette variable. Représenter la variable discrétisée sur une carte, en créant préalablement une nouvelle palette de couleurs ayant le bon nombre de classes.

```{r}
table(popcomfm_sf$densite_c)
pal2 <- c(
  RColorBrewer::brewer.pal(
  n=5,
  name="Greens"
  )[4:3],
  RColorBrewer::brewer.pal(
  n=5,
  name="YlOrRd"
  )[c(2,4:5)]
)
plot(
  popcomfm_sf["densite_c"], 
  pal=pal2, 
  border = FALSE,
  main = "Densité de population",
  )
```


## Exercice 2

Représenter sous forme de carte le taux de pauvreté par département. Vous utiliserez le package mapsf. Vous trouverez de la documentation sur ce package ici. Vous utiliserez le fond “dep_francemetro_2021” ainsi que le ﬁchier “Taux_pauvrete_dept_2021.xlsx” présent dans le dossier “U:/Eleves/Cartographie/Donnees”. Pour l’import de ce ﬁchier, vous pouvez utiliser la fonction openxlsx::read.xlsx().

### Question1

Dans un premier temps, vous pourrez essayer de faire 3 cartes basiques : une en découpant la variables d’intérêt selon la méthode de Fisher (breaks=“ﬁsher”), une autre avec des classes de même amplitude (“equal”) et enﬁn selon la méthode des quantiles (“quantile”)

```{r}
library(mapsf)
library(openxlsx)
library(sf)

```

```{r}
# Lire le fichier Excel
donnees <- openxlsx::read.xlsx("Fonds_carte/Donnees/Taux_pauvrete_2018.xlsx")


```

```{r}
# Charger le fond de carte
dep= st_read("Fonds_carte/France_metro/dep_francemetro_2021.shp", options = "ENCODING=WINDOWS-1252") 

dep= dep %>%
  left_join(donnees%>%select(-Dept),
            by=c("code"="Code"))
```


Méthode de Fisher
```{r}
mf_map(x= dep,
       var = "Tx_pauvrete",
       type = "choro",
       nbreaks = 4,
       breaks = "jenks"
)

```

Méthode des classes de même amplitude

```{r}
mf_map(x= dep,
       var = "Tx_pauvrete",
       type = "choro",
       nbreaks = 4,
       breaks = "equal"
)
```



```{r}
mf_map(x= dep,
       var = "Tx_pauvrete",
       type = "choro",
       nbreaks = 4,
       breaks = "quantile"
)
```

### Question2
Dans un 2e temps, vous ferez un découpages manuel avec les seuils suivants : 0, 13, 17, 25, max(Tx_pauvrete). La carte contiendra également un zoom sur Paris et sa petite couronne (departements 75, 92, 93, 94).

creation d'un encadre pour notre carte
```{r}
mf_map(x= dep,
       var = "Tx_pauvrete",
       type = "choro",
       nbreaks = 4,
       breaks = "quantile"
)
mf_inset_on(x= dep, pos = "topright",
            cex= ,2)
mf_init(dep %>%
          filter(code  %in% c("75", "92", "93", "94")))
mf_map(dep %>%
         filter(code  %in% c("75", "92", "93", "94")),
       var = "Tx_pauvrete",
       type = "choro",
       breaks = c(0, 13, 17, 25, max(dep$Tx_pauvrete)),
       pal= couleur,
       leg_pos = NA)

#mf_inset_on(x= dep,pos= "topright",
            )


```
```{r}

```

